#!/usr/bin/env python3
"""Generate static LUT data for sin/cos and baro powf.

Writes rust/src/lut_data.rs with:
  - SIN_TABLE: 8192 entries, quarter-wave, index i → sin(i/8191 × π/2)
  - BARO_POW_TABLE: 8192 entries, index i → (i/8191)^BARO_EXPONENT

Resolution is high enough that nearest-index lookup (no interpolation)
gives < 2e-4 max absolute error for sin/cos and < 0.05% relative error
for the baro power function.
"""

import math
import os

SIN_N = 8192
BARO_N = 8192
BARO_EXPONENT = (8.314 * 0.0065) / (9.80665 * 0.02896)  # ≈ 0.190285
COLS = 8  # values per line

OUTPATH = os.path.join(os.path.dirname(__file__), "rust", "src", "lut_data.rs")


def fmt(v: float) -> str:
    return f"{v:.10e}"


def write_table(f, name: str, n: int, gen):
    f.write(f"pub static {name}: [f32; {n}] = [\n")
    for row_start in range(0, n, COLS):
        row_end = min(row_start + COLS, n)
        vals = [fmt(gen(i)) for i in range(row_start, row_end)]
        f.write("    " + ", ".join(vals) + ",\n")
    f.write("];\n")


def main():
    with open(OUTPATH, "w") as f:
        f.write("// Auto-generated by gen_lut.py — do not edit by hand.\n")
        f.write(f"// SIN_N = {SIN_N}, BARO_N = {BARO_N}\n")
        f.write(f"// BARO_EXPONENT = {BARO_EXPONENT}\n\n")

        f.write("use core::f32::consts::{FRAC_PI_2, PI, TAU};\n\n")

        # --- Sin table ---
        f.write(f"// Quarter-wave sin, {SIN_N} entries, index i → sin(i/{SIN_N - 1} × π/2)\n")
        write_table(f, "SIN_TABLE", SIN_N, lambda i: math.sin(i / (SIN_N - 1) * math.pi / 2))

        f.write("\n")

        # --- Baro pow table ---
        f.write(f"// x^{BARO_EXPONENT:.6f}, {BARO_N} entries, index i → (i/{BARO_N - 1})^exp\n")
        write_table(
            f,
            "BARO_POW_TABLE",
            BARO_N,
            lambda i: (i / (BARO_N - 1)) ** BARO_EXPONENT if i > 0 else 0.0,
        )

        f.write(f"\npub const SIN_TABLE_N: usize = {SIN_N};\n")
        f.write(f"pub const BARO_TABLE_N: usize = {BARO_N};\n")
        f.write(f"pub const BARO_EXPONENT: f32 = {BARO_EXPONENT};\n")

        # --- Lookup functions (no interpolation, nearest index) ---
        f.write("""
/// Fast sin via quarter-wave LUT. Nearest-index, no interpolation.
#[inline]
pub fn sin_lut(mut x: f32) -> f32 {
    // Reduce to [0, 2π)
    x = x % TAU;
    if x < 0.0 { x += TAU; }

    let n = (SIN_TABLE_N - 1) as f32;
    let scale = n / FRAC_PI_2;

    if x < FRAC_PI_2 {
        // Q1
        let idx = (x * scale + 0.5) as usize;
        SIN_TABLE[idx.min(SIN_TABLE_N - 1)]
    } else if x < PI {
        // Q2: sin(π - x)
        let idx = ((PI - x) * scale + 0.5) as usize;
        SIN_TABLE[idx.min(SIN_TABLE_N - 1)]
    } else if x < PI + FRAC_PI_2 {
        // Q3: -sin(x - π)
        let idx = ((x - PI) * scale + 0.5) as usize;
        -SIN_TABLE[idx.min(SIN_TABLE_N - 1)]
    } else {
        // Q4: -sin(2π - x)
        let idx = ((TAU - x) * scale + 0.5) as usize;
        -SIN_TABLE[idx.min(SIN_TABLE_N - 1)]
    }
}

/// Fast cos via sin LUT: cos(x) = sin(x + π/2).
#[inline]
pub fn cos_lut(x: f32) -> f32 {
    sin_lut(x + FRAC_PI_2)
}

/// Fast x^BARO_EXPONENT for x ∈ [0, 1] via direct LUT lookup.
/// Used only for the barometric altitude formula.
#[inline]
pub fn powf_baro(x: f32) -> f32 {
    if x <= 0.0 { return 0.0; }
    if x >= 1.0 { return 1.0; }
    let idx = (x * ((BARO_TABLE_N - 1) as f32) + 0.5) as usize;
    BARO_POW_TABLE[idx.min(BARO_TABLE_N - 1)]
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn sin_lut_accuracy() {
        let mut max_err: f32 = 0.0;
        let steps = 100_000;
        for i in 0..=steps {
            let x = (i as f32 / steps as f32) * TAU - PI;
            let expected = libm::sinf(x);
            let got = sin_lut(x);
            let err = (got - expected).abs();
            if err > max_err { max_err = err; }
        }
        assert!(max_err < 2.0e-4, "sin_lut max error = {max_err}");
    }

    #[test]
    fn cos_lut_accuracy() {
        let mut max_err: f32 = 0.0;
        let steps = 100_000;
        for i in 0..=steps {
            let x = (i as f32 / steps as f32) * TAU - PI;
            let expected = libm::cosf(x);
            let got = cos_lut(x);
            let err = (got - expected).abs();
            if err > max_err { max_err = err; }
        }
        assert!(max_err < 2.0e-4, "cos_lut max error = {max_err}");
    }

    #[test]
    fn powf_baro_accuracy() {
        let exponent = BARO_EXPONENT;
        let mut max_rel_err: f32 = 0.0;
        let steps = 100_000;
        for i in 1..=steps {
            let base = i as f32 / steps as f32;
            let expected = libm::powf(base, exponent);
            let got = powf_baro(base);
            let rel = if expected.abs() > 1e-10 {
                ((got - expected) / expected).abs()
            } else { 0.0 };
            if rel > max_rel_err { max_rel_err = rel; }
        }
        assert!(max_rel_err < 5e-4,
            "powf_baro max relative error = {max_rel_err} (want < 0.05%)");
    }
}
""")

    print(f"Wrote {OUTPATH}")

    # Quick sanity: max sin error
    max_err = 0.0
    for i in range(100_001):
        x = (i / 100_000) * 2 * math.pi - math.pi
        expected = math.sin(x)
        # simulate nearest-index lookup
        x_mod = x % (2 * math.pi)
        if x_mod < 0:
            x_mod += 2 * math.pi
        hp = math.pi / 2
        if x_mod < hp:
            idx = round(x_mod / hp * (SIN_N - 1))
            got = math.sin(idx / (SIN_N - 1) * hp)
        elif x_mod < math.pi:
            idx = round((math.pi - x_mod) / hp * (SIN_N - 1))
            got = math.sin(idx / (SIN_N - 1) * hp)
        elif x_mod < math.pi + hp:
            idx = round((x_mod - math.pi) / hp * (SIN_N - 1))
            got = -math.sin(idx / (SIN_N - 1) * hp)
        else:
            idx = round((2 * math.pi - x_mod) / hp * (SIN_N - 1))
            got = -math.sin(idx / (SIN_N - 1) * hp)
        err = abs(got - expected)
        if err > max_err:
            max_err = err
    print(f"  sin max abs error (Python check): {max_err:.2e}")

    # Quick sanity: max baro powf error
    max_rel = 0.0
    for i in range(1, 100_001):
        x = i / 100_000
        expected = x**BARO_EXPONENT
        idx = round(x * (BARO_N - 1))
        got = (idx / (BARO_N - 1)) ** BARO_EXPONENT if idx > 0 else 0.0
        rel = abs(got - expected) / expected if expected > 1e-10 else 0.0
        if rel > max_rel:
            max_rel = rel
    print(f"  baro powf max rel error (Python check): {max_rel:.2e}")


if __name__ == "__main__":
    main()
