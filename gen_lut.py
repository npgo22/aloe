#!/usr/bin/env python3
"""Generate static LUT data for sin/cos and baro powf.

Writes rust/src/lut_data.rs with:
  - SIN_TABLE: 8192 entries, quarter-wave, index i → sin(i/8191 × π/2)
  - BARO_POW_TABLE: 8192 entries, index i → (i/8191)^BARO_EXPONENT
  - PRESSURE_TO_ALTITUDE_LUT: 8192 entries, pressure ratio → altitude (m)

Resolution is high enough that nearest-index lookup (no interpolation)
gives < 2e-4 max absolute error for sin/cos and < 0.05% relative error
for the baro power function.
"""

import math
import os

SIN_N = 8192
BARO_N = 8192
BARO_EXPONENT = (8.314 * 0.0065) / (9.80665 * 0.02896)  # ≈ 0.190285
COLS = 8  # values per line

OUTPATH = os.path.join(os.path.dirname(__file__), "rust", "src", "lut_data.rs")

# ISA (International Standard Atmosphere) model constants
G0 = 9.80665  # m/s^2
R = 287.05  # J/(kg·K) specific gas constant for air
T0 = 288.15  # K, sea level standard temperature
P0 = 101325.0  # Pa, sea level standard pressure

# ISA atmospheric layers (base geopotential altitude, base temperature, temperature lapse rate)
ISA_LAYERS = [
    (0, 288.15, -0.0065),  # Troposphere: 0-11km
    (11000, 216.65, 0.0),  # Tropopause: 11-20km (isothermal)
    (20000, 216.65, 0.001),  # Stratosphere 1: 20-32km
    (32000, 228.65, 0.0028),  # Stratosphere 2: 32-47km
    (47000, 270.65, 0.0),  # Stratopause: 47-51km (isothermal)
    (51000, 270.65, -0.0028),  # Mesosphere 1: 51-71km
    (71000, 214.65, -0.002),  # Mesosphere 2: 71-84.852km
]


def isa_pressure_at_altitude(alt_m: float) -> float:
    """Calculate pressure at given altitude using full ISA model."""
    alt_m = max(0.0, alt_m)

    for i, (base_alt, base_temp, lapse) in enumerate(ISA_LAYERS):
        next_base_alt = ISA_LAYERS[i + 1][0] if i + 1 < len(ISA_LAYERS) else 86000

        if alt_m <= next_base_alt:
            layer_alt = alt_m - base_alt

            if abs(lapse) < 1e-10:
                # Isothermal layer
                # p = p_base * exp(-g0 * h / (R * T))
                p_base = isa_pressure_at_altitude(base_alt) if base_alt > 0 else P0
                return p_base * math.exp(-G0 * layer_alt / (R * base_temp))
            else:
                # Lapse rate layer
                # p = p_base * (T / T_base)^(g0 / (R * L))
                t = base_temp + lapse * layer_alt
                if base_alt == 0:
                    p_base = P0
                else:
                    p_base = isa_pressure_at_altitude(base_alt)
                exponent = G0 / (R * lapse)
                return p_base * (t / base_temp) ** exponent

    # Above defined layers, approximate
    return 0.0


def fmt(v: float) -> str:
    return f"{v:.10e}"


def write_table(f, name: str, n: int, gen):
    f.write(f"pub static {name}: [f32; {n}] = [\n")
    for row_start in range(0, n, COLS):
        row_end = min(row_start + COLS, n)
        vals = [fmt(gen(i)) for i in range(row_start, row_end)]
        f.write("    " + ", ".join(vals) + ",\n")
    f.write("];\n")


def main():
    with open(OUTPATH, "w") as f:
        f.write("// Auto-generated by gen_lut.py — do not edit by hand.\n")
        f.write("#![allow(dead_code, clippy::excessive_precision)]\n")
        f.write(f"// SIN_N = {SIN_N}, BARO_N = {BARO_N}\n")
        f.write(f"// BARO_EXPONENT = {BARO_EXPONENT}\n\n")

        f.write("use core::f32::consts::{FRAC_PI_2, PI, TAU};\n\n")

        # --- Sin table ---
        f.write(f"// Quarter-wave sin, {SIN_N} entries, index i → sin(i/{SIN_N - 1} × π/2)\n")
        write_table(f, "SIN_TABLE", SIN_N, lambda i: math.sin(i / (SIN_N - 1) * math.pi / 2))

        f.write("\n")

        # --- ISA pressure-to-altitude LUT (0 to 50km altitude range) ---
        # Generate by sampling pressure at regular altitude intervals
        ALT_LUT_MAX = 50000  # 50km max
        ALT_LUT_STEPS = 8192
        f.write(f"// ISA pressure-to-altitude LUT, {ALT_LUT_STEPS} entries\n")
        f.write("// Index maps pressure ratio (P/P0 from 0 to 1) to altitude in meters\n")
        f.write(f"// Valid for altitudes 0-{ALT_LUT_MAX}m (0-50km)\n")

        # Generate altitude samples and corresponding pressure ratios
        alt_samples = []
        for i in range(ALT_LUT_STEPS):
            # Logarithmic sampling of pressure ratio
            # Lower altitudes have more resolution
            t = i / (ALT_LUT_STEPS - 1)
            # Use logarithmic spacing: more resolution at high altitude (low pressure)
            pr = 10 ** (-5 * t)  # Pressure ratio from 1.0 to 1e-5
            alt_samples.append(pr)

        # Now create inverse LUT: pressure ratio -> altitude
        # Sample altitudes and build table
        pressure_ratios = []
        altitudes_m = []
        for i in range(10000):
            alt = i * 5  # Every 5m up to 50km
            pr = isa_pressure_at_altitude(alt) / P0
            pressure_ratios.append(pr)
            altitudes_m.append(alt)

        # Build LUT: for each pressure ratio index, find corresponding altitude
        def pressure_to_altitude_lut(i: int) -> float:
            """Map pressure ratio index to altitude."""
            t = i / (ALT_LUT_STEPS - 1)
            pr_target = 10 ** (-5 * t)  # Target pressure ratio

            # Find altitude by binary search
            lo, hi = 0, len(pressure_ratios) - 1
            while lo < hi:
                mid = (lo + hi) // 2
                if pressure_ratios[mid] > pr_target:
                    lo = mid + 1
                else:
                    hi = mid

            # Interpolate
            if lo == 0:
                return altitudes_m[0]
            if lo >= len(altitudes_m):
                return altitudes_m[-1]

            pr_lo, pr_hi = pressure_ratios[lo - 1], pressure_ratios[lo]
            alt_lo, alt_hi = altitudes_m[lo - 1], altitudes_m[lo]

            if abs(pr_hi - pr_lo) < 1e-15:
                return alt_lo

            frac = (pr_target - pr_lo) / (pr_hi - pr_lo)
            return alt_lo + frac * (alt_hi - alt_lo)

        write_table(f, "PRESSURE_TO_ALTITUDE_LUT", ALT_LUT_STEPS, pressure_to_altitude_lut)

        f.write(f"\npub const SIN_TABLE_N: usize = {SIN_N};\n")
        f.write(f"pub const ALTITUDE_LUT_N: usize = {ALT_LUT_STEPS};\n")
        f.write("pub const ALTITUDE_LUT_MAX_ALT_M: f32 = 50000.0;  // 50km\n")
        f.write("pub const ALTITUDE_LUT_MIN_PRESSURE_RATIO: f32 = 1e-5;\n")

        # --- Lookup functions (no interpolation, nearest index) ---
        f.write(
            """
/// Fast sin via quarter-wave LUT. Nearest-index, no interpolation.
#[inline]
pub fn sin_lut(mut x: f32) -> f32 {
    // Reduce to [0, 2π)
    x %= TAU;
    if x < 0.0 { x += TAU; }

    let n = (SIN_TABLE_N - 1) as f32;
    let scale = n / FRAC_PI_2;

    if x < FRAC_PI_2 {
        // Q1
        let idx = (x * scale + 0.5) as usize;
        SIN_TABLE[idx.min(SIN_TABLE_N - 1)]
    } else if x < PI {
        // Q2: sin(π - x)
        let idx = ((PI - x) * scale + 0.5) as usize;
        SIN_TABLE[idx.min(SIN_TABLE_N - 1)]
    } else if x < PI + FRAC_PI_2 {
        // Q3: -sin(x - π)
        let idx = ((x - PI) * scale + 0.5) as usize;
        -SIN_TABLE[idx.min(SIN_TABLE_N - 1)]
    } else {
        // Q4: -sin(2π - x)
        let idx = ((TAU - x) * scale + 0.5) as usize;
        -SIN_TABLE[idx.min(SIN_TABLE_N - 1)]
    }
}

/// Fast cos via sin LUT: cos(x) = sin(x + π/2).
#[inline]
pub fn cos_lut(x: f32) -> f32 {
    sin_lut(x + FRAC_PI_2)
}

/// Convert pressure ratio (P/P0) to altitude using full ISA model LUT.
/// Valid for altitudes up to 50km.
/// More accurate than the simple hypsometric formula for high altitudes.
#[inline]
pub fn pressure_ratio_to_altitude_lut(pressure_ratio: f32) -> f32 {
    if pressure_ratio >= 1.0 {
        return 0.0;  // At or below ground level
    }
    if pressure_ratio <= ALTITUDE_LUT_MIN_PRESSURE_RATIO {
        return ALTITUDE_LUT_MAX_ALT_M;  // Above 50km, clamp
    }

    // Convert pressure ratio to index using logarithmic mapping
    // pr = 10^(-5 * t), so t = -log10(pr) / 5
    let t = -libm::log10f(pressure_ratio) / 5.0;
    let idx = (t * ((ALTITUDE_LUT_N - 1) as f32) + 0.5) as usize;
    PRESSURE_TO_ALTITUDE_LUT[idx.min(ALTITUDE_LUT_N - 1)]
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn sin_lut_accuracy() {
        let mut max_err: f32 = 0.0;
        let steps = 100_000;
        for i in 0..=steps {
            let x = (i as f32 / steps as f32) * TAU - PI;
            let expected = libm::sinf(x);
            let got = sin_lut(x);
            let err = (got - expected).abs();
            if err > max_err { max_err = err; }
        }
        assert!(max_err < 2.0e-4, "sin_lut max error = {max_err}");
    }

    #[test]
    fn cos_lut_accuracy() {
        let mut max_err: f32 = 0.0;
        let steps = 100_000;
        for i in 0..=steps {
            let x = (i as f32 / steps as f32) * TAU - PI;
            let expected = libm::cosf(x);
            let got = cos_lut(x);
            let err = (got - expected).abs();
            if err > max_err { max_err = err; }
        }
        assert!(max_err < 2.0e-4, "cos_lut max error = {max_err}");
    }
}
"""
        )

    print(f"Wrote {OUTPATH}")

    # Quick sanity: max sin error
    max_err = 0.0
    for i in range(100_001):
        x = (i / 100_000) * 2 * math.pi - math.pi
        expected = math.sin(x)
        # simulate nearest-index lookup
        x_mod = x % (2 * math.pi)
        if x_mod < 0:
            x_mod += 2 * math.pi
        hp = math.pi / 2
        if x_mod < hp:
            idx = round(x_mod / hp * (SIN_N - 1))
            got = math.sin(idx / (SIN_N - 1) * hp)
        elif x_mod < math.pi:
            idx = round((math.pi - x_mod) / hp * (SIN_N - 1))
            got = math.sin(idx / (SIN_N - 1) * hp)
        elif x_mod < math.pi + hp:
            idx = round((x_mod - math.pi) / hp * (SIN_N - 1))
            got = -math.sin(idx / (SIN_N - 1) * hp)
        else:
            idx = round((2 * math.pi - x_mod) / hp * (SIN_N - 1))
            got = -math.sin(idx / (SIN_N - 1) * hp)
        err = abs(got - expected)
        if err > max_err:
            max_err = err
    print(f"  sin max abs error (Python check): {max_err:.2e}")


if __name__ == "__main__":
    main()
